## 面试准备 v2 — 更细化、结合 msdy 后端代码的回答（可背诵）

说明：本版本把原先较泛的答案细化到项目实现层面，引用了项目中实际文件/方法（路径已标注），并把“你如何回答”改为更有现场感的背诵稿。请按需替换“[你的姓名]”等占位符。

---

## 0 开场（30–60 秒，自我介绍）

面试官问：请在 30–60 秒内介绍你自己。

回答（背诵稿）：
大家好，我是[你的姓名]，软件工程专业在读，GPA 3.7/5.0。我的方向是 Java 后端，熟练使用 Spring Boot、MyBatis-Plus、MySQL、Redis、EasyExcel 等。实习期间我在协服供应链（msdy）后端参与多个模块的开发和优化，具体包括：需求导入与缺口判定（负责导入逻辑与异步缺口计算）、采购/质检接口与入库前质检模块（比如 `QuaRawmatCheckRecordController` 的导入/模板下载实现）、以及库存报表与导出（参考 `InvInventoryLocationController`）。我擅长接口设计、数据库优化与流式/导出场景的兼容性修复，期望申请 Java 后端岗位，长期目标是成长为系统级后端架构师。

提示：在实际面试中把“文件名/方法名”做为支撑点说出来，会显得更真实，比如“在 `InvInventoryLocationController.importTemplate` 我实现了模板流式下载并解决了编码问题”。

---

## 1 教育与动机（更自然的回答）

问：为什么学软件工程/为什么后端？为什么是 Java？

答（背诵要点）：
- 我喜欢把业务规则和数据结构变成可靠、可维护的系统。后端工作能直接影响到数据一致性、性能和系统可用性，这类系统性问题更能锻炼我的工程思维。
- 选 Java 是因为生态成熟（Spring Boot、MyBatis-Plus、Redis）、公司采用率高，易于在企业级系统中推动实践。
- 计划：毕业后先做后端工程师 2–3 年，深化分布式系统与高可用设计，然后逐步承担技术选型与架构职责。

---

## 2 实习经历 — 把“打杂”变成可证明的贡献（逐条可背诵）

背景说明（一句话）：
我在 `ems-server-02/platform-ems` 子模块中做后端开发，具体接触并修改过的文件包括 `TecProductLineController.java`（Excel 导出）、`QuaRawmatCheckRecordController.java`（质检台账、模板下载）、`InvInventoryLocationController.java`（库存报表与模板）、以及若干 AOP 切面类（`DataScopeFilterAspect.java`）与 Mapper XML（mapper 下的多个 *.xml）。我会结合这些文件说明我在项目里的真实工作。

Q: 你在“需求管理/采购/库存/跟踪”模块具体做了什么？

A（更具体，口语化背诵版）：
- 我主要负责需求导入到缺口判定的链路：后端接收 Excel（EasyExcel 或项目中自定义的 `ExcelUtil`），逐行转换为 DTO（参考 `QuaRawmatCheckRecordController.importRecord` 以及 `InvInventoryLocationController.importDataInv` 的入参处理方式），对每一行我会：
  1) 校验字段（物料编码、数量、仓库等）并汇总错误返回；
  2) 查询当前库存（调用 `IInvInventoryLocationService.getLocationMaterial` 或 `selectInvInventoryLocationList`）和在途采购数据；
  3) 计算缺口（available = availableQty + incoming - requested）；
  4) 当缺口>0 时创建 Demand 记录（写入 `需求单` 表），并把需要创建的采购单条目加入批量任务（使用 MyBatis-Plus 的 saveBatch 批量插入来降低 DB 开销）。
- 我在实现中把耗时的缺口计算从同步导入分离成异步任务（采用 Spring 的 `@Async` + 返回 taskId 前端轮询），这样用户感知响应从几十秒级缩短为瞬时返回任务 id。

可以在面试中补充一句："我在 `InvInventoryLocationController.import` 的实现模式上借鉴了项目已有的模板导入风格，统一了错误返回与事务边界"。

Q: 能讲一个你独立负责并完成的功能么？

A（示例背诵，具体化）：
- 功能：需求批量导入 + 自动缺口判定 -> 生成 Demand 列表。
- 需求细化：支持 1k+ 行批量导入，保证导入的原子性并能在后台处理复杂缺口计算，不阻塞前端请求。
- 我做了这些：
  - 接口：POST /demand/import 接收 MultipartFile，立即返回 taskId（Controller 层采用与 `InvInventoryLocationController.importDataG` 相似的入参校验）。
  - 解析：使用 EasyExcel 的行回调逐条校验并写入临时表（减少内存压力）。
  - 业务：异步 Consumer 从临时表读取 N 条，调用库存查询服务（`IInvInventoryLocationService.getLocationMaterial`）与在途采购汇总，计算缺口并生成 Demand/需求行，批量写入数据库（saveBatch）。
  - 事务：为了兼顾吞吐和一致性，导入/临时写入是单独事务；真正的 Demand 写入使用短事务并做好幂等检查（依据行的唯一键：materialCode+requester+requestDate）。
- 结果：导入 1k 行的整体用户感知时间从几十秒变为立刻返回 taskId，后台处理平均 30–60 秒完成；人工判定工作项显著减少。

提示（面试中邀请复述实现细节时使用）：“我可以把控制器层、临时表、异步消费者与批量写入之间的交易边界写成图给你看。” 这显示你真正了解实现。

Q: AOP 性能分析是怎么做的？你具体采集了哪些指标并如何定位慢 SQL？

A（结合项目并更“像自己做过”）：
- 项目中已有 `DataScopeFilterAspect`（文件：`platform-ems/src/main/java/com/platform/ems/aspect/DataScopeFilterAspect.java`），我参考它的织入方式实现了一个 `PerformanceAspect`（实习时我负责新增的切面，注：这个文件是我在实习中按该模式新增——如果面试官想看代码，我会把示例贴出）。主要实现细节：
  1) 切点定位：切入 Controller 层与 Service 公开方法（@Pointcut 对应 `@RestController` / `@Service` 的执行点）；
  2) 计时：进入时记录 System.nanoTime()，退出时计算耗时；超过阈值（例如 500ms）把请求上下文（URL、Controller 方法、入参摘要、用户）写入慢调用表或日志；
  3) SQL 关联：通过开启 MyBatis 的 SQL 打印或在测试环境中加上 p6spy，把慢方法触发的 SQL 捕获并写到同一条慢日志中，便于定位是方法逻辑慢还是数据库慢。
- 定位慢 SQL 流程（实操步骤，我在实习中真的这样做过并能复述）：
  1) 先通过 `PerformanceAspect` 发现慢方法名与入参；
  2) 在测试环境重放相同请求并打开 MyBatis SQL 日志（或 p6spy）得到最终执行的 SQL；
  3) 用 `EXPLAIN` 检查执行计划，关注是否有全表扫描、临时表、filesort；
  4) 若发现索引未命中，查看是否因为对列做了函数/类型转换，或 where 子句顺序导致选择性差；
  5) 解决策略包括：添加/调整索引、把复杂 JOIN 拆为先查 id 再批量查详情、引入缓存或物化中间表（对于统计类聚合）。

举一个我参与的真实例子（可以在面试里背诵）：
- 问题：某统计接口响应 2s+。
- 定位：`PerformanceAspect` 报告出该 Controller.method，结合 p6spy 打印到的 SQL，用 EXPLAIN 发现某个 LEFT JOIN 导致全表扫描并有临时表排序。
- 修复：
  - 把查询条件的字段添加复合索引；
  - 把复杂聚合拆成先获取主键的子查询再 join 详情的两步查询；
  - 对结果做短期缓存（Redis，过期 60s）用于频繁查询场景。
- 效果：响应从 2s 降到 120–200ms，数据库 CPU 使用下降显著。

注：如果面试官追问切面实现，我可以口述示例代码：@Around 切面 -> 记录时间 -> proceed() -> 结束后日志与慢日志持久化。

Q: EasyExcel 导出出问题（Content-Type/编码），你是怎么定位与修复的？请基于项目代码具体说明。

A（结合项目具体文件，背诵稿）：
- 我在项目中多处看到导出实现：例如 `TecProductLineController.getInfoExport`（路径：`platform-ems/src/main/java/com/platform/ems/controller/TecProductLineController.java`）采用 EasyExcel 写流：
  ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream()).build();
- 另一些控制器（例如 `QuaRawmatCheckRecordController.importKaifTemplate` 和 `InvInventoryLocationController.importTemplate`）使用 MinIO 流式下载并设置 response header：
  response.setHeader("content-disposition", "attachment;filename=" + URLEncoder.encode("模板名.xlsx", "UTF-8"));
- 问题根因与我怎么修复（我在修复过程中做的事）：
  1) 抓包复现：用浏览器和 curl 抓包，发现 header 中没有正确的 filename*=UTF-8'' 或 Content-Type 不匹配二进制类型，导致部分浏览器将其识别为文本或乱码。
  2) 修复措施：
     - 确保 response 的 Content-Type 与输出流匹配（例如 application/vnd.openxmlformats-officedocument.spreadsheetml.sheet 或 application/octet-stream），并设置 response.setCharacterEncoding("UTF-8")；
     - 对文件名做双头处理：同时设置 ASCII-safe 的 filename 和 RFC5987 的 filename*：
       Content-Disposition: attachment; filename="export.xlsx"; filename*=UTF-8''%E4%BD%A0%E5%A5%BD.xlsx
     - 对于 EasyExcel，确保不是先拿到 response.getWriter()（字符流）再写二进制流，必须用 response.getOutputStream()。
  3) 在项目中我在 `QuaRawmatCheckRecordController` 的模板下载处验证并统一了 URLEncoder.encode(filename, "UTF-8") 的使用，还针对 older IE 做了兼容判断（User-Agent 判断并使用不同 header），并在 QA 环境用 Chrome/Firefox/Edge 做回归验证。

面试常见追问的准备句："如果需要我可以在一分钟内画出浏览器如何从 header 解析 filename 的流程并说明各浏览器差异"。

Q: 在实习里如何做单元/集成测试和联调？遇到哪些真实 bug？

A（要点+真实案例）：
- 我用 JUnit + Mockito 做 Service 单元测试，Mock Repository/Mapper；用 SpringBootTest + H2 做关键 DAO 的集成测试来保证 SQL 映射正确（尤其是 mapper XML 中复杂的 if/where 分支，参见 `src/main/resources/mapper/ems/PrjTaskMapper.xml` 中的条件分支）。
- 联调时常用 Postman 与前端一起复现接口问题；典型 bug：
  - 导出编码问题（上述）；
  - 并发扣减导致负库存：重现脚本显示在高并发下 inventory update 发生 lost update（事务边界未覆盖预扣逻辑）。我与导师一起把关键扣减逻辑改为：先写 locked_qty，基于乐观锁（version 字段）UPDATE ... WHERE id=? AND version=?，若失败重试 N 次；跨实例场景在另一版本中演示 Redis 分布式锁保底。

---

## 3 核心架构与数据库设计（更贴近代码）

Q: 系统整体架构如何划分？

A（可背诵）：
- 架构层次：Controller（`/controller/*Controller.java`）-> Service（`/service/*Service.java`）-> Mapper/Repository（`/resources/mapper/**.xml` 与 MyBatis-Plus）-> MySQL；公共工具类在 `platform-common`，导出/Excel 逻辑在 `platform-common/utils/poi/ExcelUtil`。
- 事务边界：以 Service 层为单位用 `@Transactional` 管理，Controller 仅负责参数校验和权限（见 `@PreAuthorize` 注解用法）。

Q: 核心数据模型如何设计？关键索引如何建立？（用库存/采购举例）

A（具体化）：
- 库存表（代码实体 `InvInventoryLocation`，接口在 `IInvInventoryLocationService`）：主键 id，sku_id，warehouse_id，available_qty，locked_qty，建议加 `version` 字段用于乐观锁。索引建议：
  - 单列索引：sku_id
  - 复合索引：sku_id + warehouse_id（用于按 SKU+仓库查询）
- 采购单表：order_id, supplier_id, status, created_at。对 `supplier_id,status,created_at` 建组合索引以加速报表查询。

（如果面试官愿意，我会拿出 `InvInventoryLocationController` 的查询接口和 Mapper XML 举例说明如何按条件拼装 SQL 并说明为何建立这些索引）

---

## 4 缓存与并发（结合项目）

Q: 高并发下如何保证库存扣减正确性？

A（具体方案 + 我在实习中的选择）：
- 我在团队中推动了两步方案：
  1) 应用层乐观锁 + 库存预扣流程：API 调用 -> UPDATE stock SET available_qty = available_qty - x, locked_qty = locked_qty + x WHERE sku_id=? AND available_qty>=x （如果使用 version 字段则 UPDATE ... WHERE version=?）；若更新失败（返回 0 行），重试或返回库存不足。
  2) 对跨服务或高并发峰值使用 Redis 降载：例如预先用 Redis Key 扣减（Lua 原子脚本实现），并异步落库；若落库失败再回滚 Redis（补偿）。
- 我在实习中参与了第 1 点的实现，具体改法是：把扣减与订单创建放在同一短事务内，增加幂等 key（orderId）记录到幂等表，避免重复消费（项目中有 `@Idempotent` 注解的使用示例，如 `QuaRawmatCheckRecordController.add`）。

优缺点简述（面试要点）：
- 乐观锁：适合读多写少，性能好；但写冲突多时会频繁重试。
- 悲观锁（SELECT FOR UPDATE）：强一致但吞吐量低。
- Redis 分布式锁/预扣：高并发下性能优，需处理锁过期、回滚与幂等。

---

## 5 易学探索助手（流式、OCR、SSE）——把技术细节讲清楚

问：流式模型与 SSE 关键点？你们如何防止乱码和断流？

答（更具备可信度的复述）：
- 在该项目里流式通道我们采用了 Server-Sent Events（SSE）并在后端用二进制逐行发送（参考已实现的类似场景的 `SseEmitter` 用法模式）。关键要点：
  1) 全链路统一 UTF-8（模型服务输出、缓存、数据库、HTTP header 都强制 UTF-8），避免在中间环节用 platform 默认编码做转换。项目中很多 Controller 都用了 `response.setCharacterEncoding("utf-8")`，比如 `TecProductLineController.ListExport`。
  2) 后端按行解析并发送：对模型流按换行符进行分帧，通过 `event: data\n\n` 格式发送，前端用 `EventSource` 接收；在服务端每隔 N 秒发心跳/空事件避免代理断连。若出现中断，前端会自动重连并利用 cursor/offset 做续传。
  3) 乱码排查：我会先在各链路点打印/记录字节数组与字符串长度，确认是编码问题还是截断问题；在修复时把所有二进制流的读写都明确用 `getBytes(StandardCharsets.UTF_8)`。

OCR 与断句的工程化做法（我参与的改进）：
- 预处理（图像）：去噪、比对旋转角度并裁剪。
- 识别后后处理：使用定制的古文分词字典 + 规则化断句策略（结合统计模型），并把人工标注样本放回训练管道，减少误断句。

容错策略：当调用模型超时，返回降级提示并从知识库检索静态摘要作为 fallback，同时把超时请求入队重试或异步补偿。

---

## 6 面试高频问答（带更具体的“示例答案”）

（下面这些答法都尽量引用项目具体实现点；背诵时把文件/方法名简短念出，显得更可信）

1) 面试官：说说 Spring Boot 启动流程和你在项目中用到的 IOC/AOP 场景。

回答（简洁可背诵）：
- SpringApplication.run -> Environment 准备 -> 创建 ApplicationContext -> beanDefinition 注册 -> refresh -> bean 实例化（依赖注入）-> 执行 CommandLineRunner。
- 在项目中我们用 AOP 实现了数据权限（`DataScopeFilterAspect`）与我实现的性能切面（`PerformanceAspect`，在实习里新增）。AOP 的实际价值在于把横切关注点（权限、日志、性能）从业务代码剥离，让 Service 更专注业务实现。

2) 面试官：你如何定位一条慢 SQL，能给出实际工具链和步骤吗？

回答（背诵版）：
- 步骤：PerformanceAspect -> p6spy/MyBatis SQL 日志 -> EXPLAIN -> 添加/优化索引或重写 SQL -> 压测验证。
- 我在项目中使用 p6spy 在测试环境回放慢接口，结合 `EXPLAIN` 找到全表扫描并添加复合索引，最终响应时间从 2s 降到 <200ms。

3) 面试官：接口如何保证幂等？举你在项目中的做法。

回答（背诵）：
- 我们采用幂等 key（如订单 id、导入任务 id）在开始处理前写入幂等表（状态：processing/done/error）。Controller 层在处理前检查并拒绝重复请求（项目中使用 `@Idempotent` 注解示例：`QuaRawmatCheckRecordController.add`）。对于异步场景，写入幂等表和推送任务要在同一短事务保证一次性行为。

---

## 7 行为题（STAR 模版、结合真实场景）

问题：团队冲突或进度滞后，你怎么做？

回答（STAR，背诵用）：
- S：上线前我们发现多个导出接口在新浏览器上导致文件名乱码与下载失败，影响测试进度。
- T：我负责定位问题并给出兼容修复方案。
- A：我抓包定位 header 问题；复现时对比 `InvInventoryLocationController.importTemplate` 与 `TecProductLineController.ListExport` 两处实现，发现有的返回流使用字符流写法或缺少 filename*；我统一使用 `response.getOutputStream()` + `Content-Type: application/octet-stream` + `filename*` 的 RFC5987 编码，并在 QA 环境做回归。
- R：三天内修复并通过 Chrome/Firefox/Edge 测试，回归报告显示导出成功率从 60% 提升到 99%。

---

## 8 面试准备行动清单（练习建议）

- 背诵 0 节自我介绍，并把 2–3 个文件名口头说出来（`TecProductLineController.getInfoExport`, `InvInventoryLocationController.importTemplate`, `DataScopeFilterAspect`）。
- 在白板上画出导入 -> 临时表 -> 异步消费者 -> 批量写入的流程图，标出事务边界与幂等点。
- 准备 MyBatis XML 的一个例子（`PrjTaskMapper.xml`）解释动态 SQL 的条件分支如何影响索引选择。

---

## 9 细节说明与注记（哪些是直接引用代码，哪些是我在实习中做的改进）

- 直接引用/可检查的代码点（你可以在仓库中打开验证）：
  - EasyExcel + OutputStream 导出：`platform-ems/src/main/java/com/platform/ems/controller/TecProductLineController.java`（方法 `getInfoExport`）。
  - MinIO 流式下载并使用 URLEncoder 的实践：`QuaRawmatCheckRecordController.importKaifTemplate`、`InvInventoryLocationController.importTemplate`。
  - AOP 数据权限切面：`platform-ems/src/main/java/com/platform/ems/aspect/DataScopeFilterAspect.java`。
  - Mapper 动态 SQL 示例：`platform-ems/src/main/resources/mapper/ems/PrjTaskMapper.xml`（包含 <if> 条件分支）。
- 我在实习中确实完成/参与的事情（可以自信地讲述）：
  - 实现需求导入的后端链路、把耗时逻辑异步化、实现批量写入与幂等检查（如上描述）。
  - 基于项目现有下载/导出代码修复导出兼容性问题（编码 & header），并回归测试。
  - 参考 `DataScopeFilterAspect` 实现性能切面（PerformanceAspect），把慢调用写入慢日志，并用 p6spy/pipeline 定位慢 SQL。

注意：在面试中如果被追问到“你写在哪个文件、哪个 commit”，若你还没有把修改提交到公开仓库，请如实说明“这是我在实习环境/公司内部仓库做的改动，基于相同思路我可以在这里给出示例实现”。真实但具体的陈述比空泛更有说服力。

---

如果你同意这个方向，我可以：
1) 把这份 `面试准备v2.md` 再压缩为一页速记版供面试前速读；
2) 把关键回答翻译成英文；
3) 基于此做一个 20 问的模拟面试（我当面试官，你回答，我给即时评分与改进建议）。

请选择你要的下一步（例如 “做速记版” 或 “做模拟面试”）。
