## 面试准备 — SCM（协服供应链系统）与易学探索助手

说明：下面的内容为面试官提问（Q）与应聘者回答（A）对照稿，已结合你在实习期间参与的协服供应链管理系统（SCM，项目目录：msdy）与易学探索助手项目的技术细节与经验，方便背诵与模拟面试。文件编码请保存为 UTF-8。

---

## 0 一句开场（30–60 秒自我介绍）

Q: 请做一个 30–60 秒的自我介绍。

A（背诵版）：
大家好，我是[你的姓名]，软件工程专业在读，GPA 3.7/5.0，主修计算机网络、操作系统、编译原理等。我的技术方向是 Java 后端开发，熟悉 Spring Boot、MyBatis-Plus、MySQL 与 Redis。在实习期间，我参与了基于 RuoYi 的协服供应链管理系统，主要负责需求管理与采购质检模块，参与 SQL 性能优化与导出功能修复；同时参与过一个基于大模型的“易学探索助手”，实现了模型流式返回与知识图谱后端。我的强项是后端接口设计、数据库优化与流式通信，期望应聘 Java 后端工程师岗位，长期目标是成为可靠的后端工程师并逐步负责系统架构设计。

---

## 1 教育与职业动机

Q: 你为什么学软件工程/后端？为什么想做 Java 后端？毕业后长期规划？

A（要点）：
- 我对系统级逻辑、数据一致性和性能优化感兴趣，后端能直接影响系统可用性与效率。
- Java 生态成熟、企业采用广泛，Spring Boot + MyBatis 的组合适合快速交付企业级业务系统。
- 长期规划：先成为高级后端工程师，掌握分布式系统与架构设计，最终向技术负责人或架构师发展。

---

## 2 实习经历 — 协服供应链管理系统（SCM）

总体说明：系统基于 RuoYi 框架（Spring Boot + MyBatisPlus + MySQL + Redis），模块化设计包括需求管理、采购、库存、质检等。我在实习中主要参与需求管理与采购/库存跟踪、质量管理模块的开发与维护，同时参与性能分析与导出功能修复。

Q: 你负责的“需求管理/采购/库存/跟踪”模块具体如何设计与实现？用到哪些接口和数据结构？

A（背诵版）：
- 核心流程：用户提交采购需求 -> 系统判定物料缺口 -> 生成采购单或驱动生产计划 -> 跟踪采购入库 -> 入库前质检 -> 更新库存与记录问题台账。
- 接口设计（RESTful）：
  - POST /api/demand/submit 提交需求（入参：物料 id、数量、期望交期、申请人）
  - GET /api/demand/{id} 查询需求详情
  - POST /api/purchase/create 生成采购单（根据缺口）
  - GET /api/stock/{sku}/availability 查询库存可用量
  - POST /api/quality/check 提交质检结果
- 关键数据结构：Demand、PurchaseOrder、PurchaseItem、Stock（sku、warehouse、availableQty、lockedQty）、QualityRecord、IssueLog。
- 存储层使用 MyBatis-Plus 的实体与 Mapper。库存表对 sku+warehouse 建复合索引，频繁按 sku 查询建立单列索引。

Q: 能讲一个你独立完成的功能吗？需求、设计、实现与结果。

A（示例背诵）：
- 功能：采购需求导入与自动缺口判定。
- 需求：支持用户批量导入需求（Excel），系统根据当前库存与在途采购计算缺口并自动生成待处理需求。
- 设计：后端使用 EasyExcel 解析上传文件 -> 校验数据格式 -> 业务层按行计算缺口（available = stock.availableQty + incoming - requested）-> 对缺口>0 的条目创建 Demand 记录并返回处理结果。
- 实现细节：
  - Controller 接收 MultipartFile，交给 EasyExcel 读取逐行 DTO。
  - 使用事务（@Transactional）保证导入与 Demand 创建原子性，批量插入使用 MyBatis-Plus 批量 saveBatch。
  - 对于耗时大步骤（计算库存与入库预测）使用异步任务（@Async）并返回任务 id 供前端轮询。
- 结果：实现后导入效率提高，减少人工判定流程，测试环境中 1k 条导入完成时间显著下降，用户满意度提高。

Q: 你如何用 AOP 做性能分析并定位慢 SQL？具体采集哪些指标？

A（背诵版）：
- 做法：在项目中编写一个性能切面（Aspect），在 Controller/Service 层织入计时逻辑，记录方法入参、出参、执行耗时并把超过阈值（比如 500ms）的调用写到慢调用日志或上报到监控系统。
- 采集指标：方法执行耗时、SQL 执行时间（可以在 MyBatis 插件/拦截器层记录）、参数、请求 URL、用户 ID、堆栈信息。
- 定位慢 SQL：通过慢方法记录反查对应的 Mapper 与执行的 SQL（可打开 MyBatis 的 SQL 日志或使用 p6spy），结合 EXPLAIN 分析查询计划、查看是否全表扫描、是否缺索引或索引选择性差，从而决策添加索引、改写 JOIN/子查询或拆分查询。

Q: 你提到使用 EasyExcel 导出遇到 Content-Type 与文件名编码问题，怎么解决的？

A（背诵版）：
- 问题：浏览器无法识别下载文件或文件名中文乱码。具体表现是前端拿到 response 后文件名为乱码或打开失败。
- 根因：后端设置的 Content-Type 与实际二进制流不匹配，且 Content-Disposition 的 filename 未做 UTF-8 或 RFC5987 编码处理，部分浏览器（IE/Edge/Chrome）对 header 编码处理不同。
- 解决：
  - 设置 response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8") 或更稳妥的 application/octet-stream。
  - 对 filename 使用 URLEncoder.encode(filename, "UTF-8")，并同时在 header 中带上两个字段：
    Content-Disposition: attachment; filename="{ascii-name}.xlsx"; filename*=UTF-8''{urlencoded-name}
  - 在后端以二进制流写出 EasyExcel 生成的 OutputStream，关闭流前 flush。
- 验证通过 Chrome/Firefox/Edge 测试，导出兼容性恢复。

Q: 你是如何做单元/集成测试和联调的？遇到过哪些 bug？如何定位？

A（要点）：
- 单元测试：使用 JUnit + Mockito 对 Service 层逻辑进行单元测试，Mock 数据库与远程服务。
- 集成测试：使用 SpringBootTest 加载上下文，结合 H2 或测试库执行 DAO 层语句，验证 MyBatis 映射。
- 联调：使用 Postman 调试接口，与前端约定返回格式与错误码；遇到跨域/鉴权问题与前端协作定位。
- 典型 bug 与定位：导出编码问题（通过抓包查看 response header）、并发库存扣减导致负库存（通过日志与重现脚本发现事务未覆盖关键区域，后续使用乐观/分布式锁方案修复）。

---

## 3 核心架构与数据库设计

Q: 系统整体架构长什么样？分层、模块、消息队列、事务边界如何划分？

A（要点）：
- 分层：Controller（API 层）-> Service（业务逻辑）-> Mapper/Repository（持久层）-> DB。
- 模块：需求、采购、库存、质检、销售、生产、报表、权限等，模块之间通过 REST 或内部 RPC/消息队列（例如 RabbitMQ/Kafka）异步解耦。
- 缓存：Redis 用于热点数据缓存、会话与短期锁/计数器。
- 事务边界：以 Service 级为主，使用 @Transactional 控制数据库事务；跨服务场景使用最终一致性（消息队列 + 补偿）或分布式事务框架（在必须保证强一致性时慎用）。

Q: 核心数据模型（采购单、库存、订单）如何设计？关键索引如何建立？

A（要点）：
- 采购单 PurchaseOrder（id, code, supplier_id, status, total_amount, created_by, created_at）
- 采购项 PurchaseItem（id, order_id, sku_id, qty, unit_price, expected_date）
- 库存 Stock（id, sku_id, warehouse_id, available_qty, locked_qty, version）
- 索引：
  - Stock: (sku_id), (sku_id, warehouse_id) 的复合索引用于快速查询仓内库存。
  - PurchaseOrder: (supplier_id, status, created_at) 用于筛选与报表。
  - 对于高基数查询字段建立 B-Tree 索引，避免在 where 中对列进行函数转换以保留索引使用。

Q: 高并发下如何保证库存扣减正确性？方案及优缺点。

A（要点）：
- 悲观锁（SELECT ... FOR UPDATE）：优点简单、强一致；缺点并发吞吐低，容易导致死锁。
- 乐观锁（version 或 compare-and-set）：优点无锁冲突，适合读多写少；缺点写冲突需重试，可能导致延迟和重试成本。
- 数据库事务＋行级锁：适用于单库场景。
- 分布式锁（Redis RedLock）：适用于跨实例，同步请求较短时效；需处理锁失效、可靠性问题。
- 业务推荐：先尝试乐观锁 + 库存预扣 + 异步补偿（消息队列），在超高并发且严格一致场景下结合分布式锁或基于数据库的库存预分配表。

---

## 4 Redis 与缓存策略

Q: 你是如何使用 Redis 的？缓存失效策略如何设计？

A（要点）：
- 用途：热点数据缓存（商品基础信息）、会话缓存、短期统计（计数器）、分布式锁（set nx）、限流（滑动窗口/漏桶实现）。
- 缓存策略：
  - 缓存穿透：对为空的 key 设置短期缓存或布隆过滤器拦截。
  - 缓存击穿：热点 key 使用互斥锁或提前刷新（预热），或使用永不过期并定期异步刷新。
  - 缓存雪崩：不同 key 的失效时间加随机抖动，避免集中过期。
- 一致性：对强一致性场景（库存）避免仅靠缓存，使用缓存 + DB 双写/回源策略并加监控。

---

## 5 SQL 优化示例（你参与的案例）

Q: 描述一次你做的 SQL 优化：原本慢在哪里，如何定位，最终怎么改？

A（背诵版）：
- 场景：某查询在生产环境中按条件联合多表时慢（>2s）。
- 定位：通过 AOP 慢方法日志定位到 Controller -> Service -> Mapper 的具体方法名，结合 MyBatis 的 SQL 打印与 p6spy 捕获最终执行 SQL。使用 EXPLAIN 查看查询计划，发现某个 JOIN 导致全表扫描，并在 where 中对索引列做了函数处理。
- 解决：
  - 为 where 中的过滤列添加合适索引（或者改用复合索引覆盖查询）。
  - 重写 SQL：避免在过滤列上使用函数，改为预计算字段或在业务上调整查询逻辑；拆分复杂 JOIN 为先查询主键再批量查细节的两步查询。
  - 对频繁展示的统计类数据引入 Redis 缓存并设置 TTL，减少实时复杂聚合的压力。
- 结果：查询响应从 2s 降到 100-200ms，明显提升体验。

---

## 6 易学探索助手（AI、OCR、SSE）要点

Q: 该系统的数据流与关键组件如何交互？

A（要点）：
- 请求流程：前端发起查询/问答请求 -> 网关/后端 API -> 检查缓存/检索知识库 -> 调用模型服务（可能并发多个模型）-> 流式接收结果 -> SSE 推送给前端 -> 结果落库/更新知识图谱。
- 关键组件：模型处理器工厂（负责按模型类型路由请求）、OCR 组件、断句与实体抽取流水线、知识图谱存储层与检索模块、SSE 推送通道。

Q: SSE 的关键实现点和避免乱码/断连的方法？

A（背诵版）：
- 实现要点：使用 Spring 的 SseEmitter 或 Servlet 输出流，设置响应头：Content-Type: text/event-stream; charset=UTF-8，并关闭缓存。后端按行发送事件，保持心跳（Comment 或空事件）以防代理/负载均衡超时。
- 避免乱码：统一使用 UTF-8 编码，确保模型输出与传输链路（数据库、缓存、HTTP header）均为 UTF-8，二进制安全传输时显式以 bytes 发送并指定编码。
- 重连策略：前端 SSE 自动重连；后端持久化会话或提供可续传 cursor 以便在重连后继续流式输出。

Q: OCR 与古文断句如何优化准确性？

A（要点）：
- 预处理：图像去噪、二值化、字符对齐与切割。
- 后处理：语言模型/字典纠错、定制古文分词词典、规则化断句与人工标注回流训练。
- 验证：建立人工标注样本集用于评估并迭代模型。

---

## 7 框架 / 工具 / 理论题简答（常考）

Q: 讲讲 Spring Boot 启动流程和 IOC/AOP 的理解。

A（要点）：
- 启动流程：SpringApplication.run -> 创建 SpringApplication 实例 -> 准备环境（Environment）、创建 ApplicationContext -> 注册 BeanDefinition -> 刷新上下文（refresh） -> 实例化单例 Bean -> 执行 CommandLineRunners -> 启动完成。
- IOC：通过 BeanFactory/ApplicationContext 管理 Bean 的生命周期与依赖注入。
- AOP：基于代理（JDK 动态代理或 CGLIB），在切点前后织入横切逻辑，常用于事务、日志、性能统计与权限校验。

Q: MyBatis-Plus 常用分页/条件构造器，如何防止 SQL 注入？

A（要点）：
- 使用 QueryWrapper、LambdaQueryWrapper 构建条件；分页使用 Page 对象。
- 防注入：避免字符串拼接 SQL，使用参数化查询、Wrapper API 与 @Param 注入参数，限制动态 SQL 的输入范围并做白名单校验。

Q: 事务管理（注解/传播/隔离）如何使用？例子说明事务嵌套或跨服务事务处理。

A（要点）：
- 常用注解：@Transactional(propagation=Propagation.REQUIRED, isolation=Isolation.DEFAULT)
- 传播行为：REQUIRED、REQUIRES_NEW、SUPPORTS 等，用于控制子事务与父事务的边界。
- 跨服务事务：使用最终一致性模式（消息队列 + 补偿）或 SAGA 模式；分布式事务（2PC）使用场景有限且复杂，通常避免。

Q: 你了解 JVM 内存模型与常见 GC 策略吗？调优思路？

A（要点）：
- JVM 内存区域：堆（Young、Old）、方法区（元空间）、栈、本地内存。
- 常见 GC：Serial、ParNew + CMS、G1、ZGC、Shenandoah 等。
- 调优思路：先通过监控（jstat/jmap/VisualVM/GC log）找出内存/GC 瓶颈，再调整堆大小、代比例、GC 策略；避免频繁 Full GC，控制对象生命周期与分配速率。

---

## 8 系统设计题：设计简化版库存服务（面试必问）

Q: 设计一个高可用的库存服务，如何保证并发扣减与跨仓并发？

A（要点与思路）：
1) API 设计：
  - POST /inventory/deduct 扣减（参数：orderId, items[{sku, qty, warehouseId}], idempotencyKey）
2) 数据模型：Stock(sku, warehouseId, availableQty, lockedQty, version)
3) 并发策略：
  - 本地：使用乐观锁（version）或悲观锁（SELECT FOR UPDATE）保证单行一致性；先将 availableQty 减少、lockedQty 增加，成功后写入锁表并返回。
  - 分布式：使用 Redis 分布式锁或基于 Redis 的令牌桶/漏桶减库存；对于跨仓并发，按仓加锁或拆单按仓并发处理，减少锁粒度。
4) 事务与补偿：
  - 使用本地事务保证单服务的一致性；跨服务通过消息队列做最终一致性（下单失败或者库存不足发送补偿消息回滚已扣减的锁）。
5) 高可用/分区：
  - 数据分区（按 SKU 范围或仓库分库分表），读写分离，缓存热点库存数据，使用异步刷新。

优缺点权衡：乐观锁适合冲突较少场景；悲观锁强一致但性能差；分布式锁需处理网络/锁过期等异常，需结合幂等与补偿策略。

---

## 9 算法与数据结构（手写题鼓点）

Q: 给定数组找两个数之和等于 target（最优时间复杂度）。

A（背诵版）：
- 思路：使用哈希表记录遍历过的数，时间复杂度 O(n)。
- 伪代码：
  - 创建空 map
  - 遍历 nums，令 needed = target - nums[i]
  - 如果 map.containsKey(needed) 返回 [map.get(needed), i]
  - 否则 map.put(nums[i], i)

Q: 常见题目要点：链表反转、二叉树遍历、LRU 原理?

A（要点）：
- 链表反转：迭代法使用 prev/curr/next；递归法通过回溯。
- 二叉树遍历：递归或栈实现的前/中/后序及层序（队列）。
- LRU：使用 HashMap + 双向链表，Map 存节点引用，链表维护访问顺序，删除尾部最久未使用。

---

## 10 行为题与协作（STAR 模板）

Q: 团队冲突或进度滞后你怎么处理？

A（示例 STAR）：
- 情境（S）：项目上线临近，前端联调遇到多处接口返回格式不一致，进度滞后。
- 任务（T）：作为后端实习生，需要协助定位问题并确保接口稳定交付。
- 行动（A）：我主动组织与前端、产品、测试的短会，梳理接口契约，更新 API 文档，并在后端增加兼容性适配（短期）与规范化改造（长期），同时写了 Postman 集成用例供测试使用。
- 结果（R）：联调问题在两天内解决，测试覆盖率提升，后续类似问题减少。

Q: 遇到最困难的技术挑战？如何解决？

A（示例）：
- 挑战：古文断句与模型流式乱码导致用户体验差。
- 解决：定制分词词典并接入人工标注回流，统一 UTF-8 编码并在 SSE 层以二进制行分隔发送，增加心跳与重连逻辑，测试后用户端体验显著改善。

---

## 11 测试/CI/部署要点

Q: 你如何做接口测试与自动化测试？CI 会加哪些检查？

A（要点）：
- 接口测试：使用 Postman / Newman 或 JUnit + Spring MockMvc 做 API 自动化；集成测试用容器化测试数据库或 Testcontainers。
- CI 检查：静态代码检查（Checkstyle/SpotBugs/PMD）、单元测试覆盖率（至少门槛）、构建验证、格式化（Prettier/Formatters）、安全扫描（依赖漏洞）。
- 部署：使用 Maven 打包为 jar（Spring Boot），结合 Docker 镜像、Kubernetes 做部署，数据库迁移使用 Flyway 或 Liquibase。

---

## 12 面试常见小窍门（如何把“打杂”经验包装成有价值的贡献）

要点：
- 强调学习路径：描述你如何从“打杂”学到需求理解、接口设计与排查问题的方法论。
- 量化成果：尽量给出数字（如查询从 2s 降到 200ms，导出问题修复后兼容 3 个主流浏览器）。
- 展示主动性：说明你如何主动定位问题、查阅资料、与团队沟通并推动落地。
- 强调技术深度：哪怕只是协助定位 SQL，你也可以说明用到的工具（p6spy/EXPLAIN/慢查询日志）与具体操作步骤，体现你理解底层原理。

示例话术（包装版）：
“在实习中我的任务不止于完成分配的开发，更注重把需求拆解并把握边界条件。比如在处理导出失败问题时，我通过抓包与对比浏览器行为，定位为 Content-Disposition 编码不当，并实现了兼容性修复，使导出功能通过三方浏览器验证。”

---

## 13 模拟问答（面试官 — 应聘者 一轮示例）

面试官（Q）：请用 30 秒介绍你自己。

应聘者（A）：（见第0节自我介绍背诵版）

面试官：你在 SCM 项目中最自豪的贡献是什么？

应聘者：我最自豪的是参与并完成了需求导入与自动缺口判定模块，原来人工并行处理耗时高，我实现了一套 EasyExcel 批量读取 + 异步缺口计算的方案，导入效率在测试环境下大幅提升，并减少了人工错误，同时在该功能中我也修复了导出时的编码问题，提升了用户体验。

面试官：说明一次你定位慢 SQL 的过程。

应聘者：我在 AOP 中记录了超时方法，定位到某统计接口；用 p6spy 打印出最终 SQL，EXPLAIN 显示是全表扫描；通过添加复合索引并把复杂聚合拆成两步查询后响应时间从 2s 降到 150ms。

面试官：如何保证库存扣减的幂等性？

应聘者：主要通过请求层的幂等 key（例如订单 id 或幂等 token）在后端做幂等检查并持久化幂等表，在执行扣减前做幂等判断并记录操作结果；结合事务与 lockedQty，实现可回滚的幂等流程。

---

## 14 练习建议与背诵清单

- 练习 1：背诵第 0 节自我介绍与第 2 节的功能实现示例。
- 练习 2：用白板写出库存扣减的并发方案（画出数据流与锁边界）。
- 练习 3：复述 SQL 优化案例（定位 -> EXPLAIN -> 索引/改写 -> 结果）。
- 练习 4：手写两数之和的哈希解法并口头解释时间复杂度。

---

## 15 总结（面试结束时可说的话）

“感谢今天的面试机会，我很享受解决工程问题与和跨职能团队协作的过程。如果有机会我希望能在贵公司继续在后端系统稳定性与性能方向深入发展，并尽快为项目产出可量化的改进。”

---

文件结束。若需我把这份内容调整为英文版本、压缩为一页速记版，或导出为 PDF/Word 供打印，请告诉我。
